package SMS4

/*
 * Implementation of the Chinese National Standard SMS4.  The reference
 * for the implementation is "SMS4 Encryption Algorithm for Wireless Networks",
 * translated by Winfield Diffie and George Ledin.
 */

import (
    "bytes"
    "encoding/binary"
)

type ZiJie byte

type Zi struct {
    b [4]ZiJie
}

type block struct {
    X [4]Zi
}

var Sbox [16][16]ZiJie = [16][16]ZiJie{
        {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7,
        0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},
        {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3,
        0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},
        {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a,
        0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},
        {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95,
        0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},
        {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba,
        0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},
        {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b,
        0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},
        {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2,
        0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},
        {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52,
        0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},
        {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5,
        0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},
        {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55,
        0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},
        {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60,
        0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},
        {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f,
        0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},
        {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f,
        0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},
        {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd,
        0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},
        {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e,
        0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},
        {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20,
        0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48},
}

var CK [32]Zi = [32]Zi{
    Zi{[4]ZiJie{0x00, 0x07, 0x0e, 0x15}}, Zi{[4]ZiJie{0x1c, 0x23, 0x2a, 0x31}},
    Zi{[4]ZiJie{0x38, 0x3f, 0x46, 0x4d}}, Zi{[4]ZiJie{0x54, 0x5b, 0x62, 0x69}},
    Zi{[4]ZiJie{0x70, 0x77, 0x7e, 0x85}}, Zi{[4]ZiJie{0x8c, 0x93, 0x9a, 0xa1}},
    Zi{[4]ZiJie{0xa8, 0xaf, 0xb6, 0xbd}}, Zi{[4]ZiJie{0xc4, 0xcb, 0xd2, 0xd9}},
    Zi{[4]ZiJie{0xe0, 0xe7, 0xee, 0xf5}}, Zi{[4]ZiJie{0xfc, 0x03, 0x0a, 0x11}},
    Zi{[4]ZiJie{0x18, 0x1f, 0x26, 0x2d}}, Zi{[4]ZiJie{0x34, 0x3b, 0x42, 0x49}},
    Zi{[4]ZiJie{0x50, 0x57, 0x5e, 0x65}}, Zi{[4]ZiJie{0x6c, 0x73, 0x7a, 0x81}},
    Zi{[4]ZiJie{0x88, 0x8f, 0x96, 0x9d}}, Zi{[4]ZiJie{0xa4, 0xab, 0xb2, 0xb9}},
    Zi{[4]ZiJie{0xc0, 0xc7, 0xce, 0xd5}}, Zi{[4]ZiJie{0xdc, 0xe3, 0xea, 0xf1}},
    Zi{[4]ZiJie{0xf8, 0xff, 0x06, 0x0d}}, Zi{[4]ZiJie{0x14, 0x1b, 0x22, 0x29}},
    Zi{[4]ZiJie{0x30, 0x37, 0x3e, 0x45}}, Zi{[4]ZiJie{0x4c, 0x53, 0x5a, 0x61}},
    Zi{[4]ZiJie{0x68, 0x6f, 0x76, 0x7d}}, Zi{[4]ZiJie{0x84, 0x8b, 0x92, 0x99}},
    Zi{[4]ZiJie{0xa0, 0xa7, 0xae, 0xb5}}, Zi{[4]ZiJie{0xbc, 0xc3, 0xca, 0xd1}},
    Zi{[4]ZiJie{0xd8, 0xdf, 0xe6, 0xed}}, Zi{[4]ZiJie{0xf4, 0xfb, 0x02, 0x09}},
    Zi{[4]ZiJie{0x10, 0x17, 0x1e, 0x25}}, Zi{[4]ZiJie{0x2c, 0x33, 0x3a, 0x41}},
    Zi{[4]ZiJie{0x48, 0x4f, 0x56, 0x5d}}, Zi{[4]ZiJie{0x64, 0x6b, 0x72, 0x79}},
}

var FK [4]Zi = [4]Zi{
    Zi{[4]ZiJie{0xa3, 0xb1, 0xba, 0xc6}},
    Zi{[4]ZiJie{0x56, 0xaa, 0x33, 0x50}},
    Zi{[4]ZiJie{0x67, 0x7d, 0x91, 0x97}},
    Zi{[4]ZiJie{0xb2, 0x70, 0x22, 0xdc}},
}

// Exlusive-OR function for SMS4 Zi
func (z1 Zi) xor(z2 Zi) Zi {
    var result Zi

    for i := 0; i < 4; i++ {
        result.b[i] = z1.b[i] ^ z2.b[i]
    }

    return result
}

// Circular shift left
func (z Zi) rotl(shift uint16) Zi {
    var value uint32
    var result Zi

    b := []byte{byte(z.b[0]), byte(z.b[1]), byte(z.b[2]), byte(z.b[3])}
    buf := bytes.NewReader(b)

    err := binary.Read(buf, binary.BigEndian, &value)
    if err != nil {
        return z
    }

    shifted := (value << shift) | (value >> (32 - shift))

    buf2 := new(bytes.Buffer)
    err = binary.Write(buf2, binary.BigEndian, shifted)
    if err != nil {
        return z
    }

    result = Zi{[4]ZiJie{ZiJie(buf2.Bytes()[0]),
                         ZiJie(buf2.Bytes()[1]),
                         ZiJie(buf2.Bytes()[2]),
                         ZiJie(buf2.Bytes()[3])}}

    return result
}

// Non-linear substitution
func Tau(A Zi) Zi {
    var B Zi

    for i := 0; i < 4; i++ {
        x := A.b[i] >> 4  // row is high 4 bits
        y := A.b[i] & 0xf // col is low 4 bits
        B.b[i] = Sbox[x][y]
    }

    return B
}

// Linear substitution (for encryption)
func L(B Zi) Zi {
    return B.xor(B.rotl(2).xor(B.rotl(10).xor(B.rotl(18).xor(B.rotl(24)))))
}

// Linear substitution (for key generation)
func Lprime(B Zi) Zi {
    return B.xor(B.rotl(13).xor(B.rotl(23)))
}

// Mixer-substitution (for encryption)
func T(A Zi) Zi {
    return L(Tau(A))
}

// Mixer-substitution (for key generation)
func Tprime(A Zi) Zi {
    return Lprime(Tau(A))
}

// The round function
func F(x block, rk Zi) Zi {
    return x.X[0].xor(T(x.X[1].xor(x.X[2].xor(x.X[3]).xor(rk))))
}

// Reverse substitution
func R(A block) block {
    return block{[4]Zi{A.X[3], A.X[2], A.X[1], A.X[0]}}
}

// Generate a round key from an encryption key
func generateRoundKey(MK block) [32]Zi {
    var K [36]Zi
    var rk [32]Zi

    K[0] = MK.X[0].xor(FK[0])
    K[1] = MK.X[1].xor(FK[1])
    K[2] = MK.X[2].xor(FK[2])
    K[3] = MK.X[3].xor(FK[3])

    for i := 0; i < 32; i++ {
        K[i+4] = K[i].xor(Tprime(K[i+1].xor(K[i+2].xor(K[i+3].xor(CK[i])))))
        rk[i] = K[i+4]
    }

    return rk
}

// Encryption
func Encrypt(X, MK block) block {
    var XX [36]Zi

    rk := generateRoundKey(MK)

    for i := 0; i < 4; i++ {
        XX[i] = X.X[i]
    }

    for i := 0; i < 32; i++ {
        XX[i+4] = F(block{[4]Zi{XX[i], XX[i+1], XX[i+2], XX[i+3]}}, rk[i])
    }

    Y := R(block{[4]Zi{XX[32], XX[33], XX[34], XX[35]}})

    return Y
}

// Decryption
func Decrypt(X, MK block) block {
    var XX [36]Zi

    rk := generateRoundKey(MK)

    for i := 0; i < 4; i++ {
        XX[i] = X.X[i]
    }

    for i := 0; i < 32; i++ {
        XX[i+4] = F(block{[4]Zi{XX[i], XX[i+1], XX[i+2], XX[i+3]}}, rk[31-i])
    }

    Y := R(block{[4]Zi{XX[32], XX[33], XX[34], XX[35]}})

    return Y
}

